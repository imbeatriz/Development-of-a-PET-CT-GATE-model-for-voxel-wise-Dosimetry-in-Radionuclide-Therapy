import numpy as np, slicer, vtk

# Segmentation and Files Node names (update to match exactly yours in the Data module)
doseNodeName = 'Patient_ADD_MCdosimetry'   # Absorbed dose distribution map (Gy) calibrated
uncNodeName  = 'DOSE_Y90-Dose-Uncertainty' # Relative statistical uncertainty map
ptvSegNodeName = 'ptv'                     # PTV segmentation node
nlvSegNodeName = 'nlv'                     # NLV segmentation node

# Number of primaries/events initially defined in the MC-GATE dosimetry simulation
# Used to scale SU for estimating required runs to reach target precision
N_current = 1.18e8

# Get dose and uncertainty volumes from the Slicer scene
doseNode = slicer.util.getNode(doseNodeName)
uncNode  = slicer.util.getNode(uncNodeName)

# Helper function to extract a binary mask from a segmentation node
def segmentation_to_mask(segNode, refNode):
    labelmapNode = slicer.mrmlScene.AddNewNodeByClass('vtkMRMLLabelMapVolumeNode', f'Label_{segNode.GetName()}')
    slicer.modules.segmentations.logic().ExportVisibleSegmentsToLabelmapNode(segNode, labelmapNode, refNode)
    mask = slicer.util.arrayFromVolume(labelmapNode) > 0
    slicer.mrmlScene.RemoveNode(labelmapNode)
    return mask

# Convert segmentations to binary masks (True inside each ROI)
mask_ptv = segmentation_to_mask(slicer.util.getNode(ptvSegNodeName), doseNode)
mask_nlv = segmentation_to_mask(slicer.util.getNode(nlvSegNodeName), doseNode)

# Get dose and statistical uncertainty (SU) voxel arrays
dose = slicer.util.arrayFromVolume(doseNode)
su   = slicer.util.arrayFromVolume(uncNode)

# Create an additional mask for PTV voxels receiving dose > 80 Gy
mask_ptv_d80 = mask_ptv & (dose > 80.0)

# Compute mean SU (%) inside a given mask
def mean_pct(arr, mask):
    if mask.sum() == 0:
        return np.nan
    return arr[mask].mean() * 100.0

# Compute mean SUs for PTV, PTV>80 Gy, and NLV regions
mean_su_ptv_all = mean_pct(su, mask_ptv)
mean_su_ptv_d80 = mean_pct(su, mask_ptv_d80)
mean_su_nlv_all = mean_pct(su, mask_nlv)

# Print mean SUs and voxel counts
print("\nResults:")
print(f"Mean SU in PTV (all voxels): {mean_su_ptv_all:.2f}%")
print(f"Mean SU in PTV (dose > 80 Gy): {mean_su_ptv_d80:.2f}%")
print(f"Mean SU in NLV (all voxels): {mean_su_nlv_all:.2f}%")
print(f"Voxel counts: PTV(all)={mask_ptv.sum()}, PTV(D>80)={mask_ptv_d80.sum()}, NLV(all)={mask_nlv.sum()}")

# Compute number of runs required to reach the target SU
current_su = mean_su_ptv_d80   # Current SU used as reference (from PTV voxels >80 Gy)
target_su = 2.0                # Target SU (%) to achieve - can be changed to the desired value

# Print results based on current SU and target SU
if np.isnan(current_su):
    print("\n No PTV voxels >80 Gy found — cannot compute SU statistics.")
elif current_su <= target_su:
    print(f"\n Target achieved: current SU = {current_su:.2f}% (≤ {target_su:.2f}%)")
else:
    M = (current_su / target_su) ** 2
    runs_required = int(np.ceil(M))
    N_required = N_current * M
    print("\nTo reduce SU from {:.2f}% to {:.2f}%:".format(current_su, target_su))
    print("- Multiplier M = {:.3f}".format(M))
    print("- If each run has N_current = {:.2e} primaries, required total N ≈ {:.3e}".format(N_current, N_required))
    print("- Equivalent to {} identical runs of size N_current (ceil(M)).".format(runs_required))
    print("- Expected SU after combining m runs: {:.2f}%".format(current_su / np.sqrt(runs_required)))
